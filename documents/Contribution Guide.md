# Contribution Guide

This document helps contributors maintain consistent code.

Please also refer to [Style Guide](Style Guide.md) for code level formatting guide.


## Code of Conduct

This project adheres to the [Open Code of Conduct](http://todogroup.org/opencodeofconduct/#appledoc/appledoc@gentlebytes.com). By participating, you are expected to honor this code.


## appledoc in a nutshell

Appledoc is source code documentation generator. It parses given set of input paths and generates DocSet bundle containing all detected documentation.

The process of converting source code comments into resulting DocSet is divided into several steps:

- **Parse source files to in-memory representation:** this is where data is extracted from source files and saved into temporary in-memory representation that's used in subsequent steps. Parsing is typically resource intensive so using in-memory representation allows fast processing and generation later on.
- **Processing in-memory representation:** after initial in-memory representation of parsed data exists, it's processed to further determine connections between classes, thus establishing cross references, linking extensions and categories with parent classes etc. As part of this step, all source code comments are processed to convert appledoc specific formatting (tags such as `@param`, cross reference links etc) into generic representation that's easily consumed by later steps.
- **Generate HTML:** after establishing all pieces, in-memory representation is used to generate HTML. Files generated by this step are already completely usable; opening html files in browser would allow you to click through cross references, so it's enough if all user needs is upload to website.
- **Generate DocSet:** converts HTML files into documentation set. This is the ultimate goal of appledoc and is needed to add documentation to Xcode or third party browsers such as [Dash](https://kapeli.com).


## Project management

Tasks that need done are reported to [appledoc Trello board](https://trello.com/b/X4nm11Hd/appledoc). Note that in Trello vocabulary tasks are called "cards" and they are listed in "lists". The board is divided into following lists:

- **Ideas:** Longer term goals and ideas. For the moment ignore it (but feel free to submit ideas; please do it in Slack channel).
- **In preparation:** Upcoming tasks. These tasks are still being prepared or are dependent on other tasks that are not complete yet. So not quite ready to be worked on, but coming soon...
- **Tasks:** This is main pool of tasks that need to be done. 
- **In progress:** The list for tasks on which work is being done at the moment.
- **Completed:** List of cards that were completed (pull request created) but not yet merged to development.
- **Tested:** List of cards that were succesfully merged to development. Eventually these cards will get archived.

The workflow:

1. Whenever you get a slot of time, take one card from **Tasks** list and:
	- Add yourself as its member so we know who's working on it (click on card and you'll see "members" button at the top right side).
	- Move the task to **In progress** list so we're all aware the task is being managed.
	- Create new branch for this task and start work there (see below).

2. After you're done with work on your card:
	- Rebase your branch on top of development and push it to github, then create pull request on github (see below). Please add the card URL to pull request description so it's easier for the one who's merging to determine what was required.
	- Move the card to **Completed** list.
	- Your job is done at this point; someone will take a look at your PR and either merge it, or ask you for additional work.
	- Feel free to take another card :)

3. If you're working on a task but can't complete it for whichever reason:
	- Rebase and push your branch to github (see below).
	- Indicate the branch you worked on in card comments.
	- Move card back to **Tasks** list.
	- Add a comment indicating what is completed, or findings of your research, links to blog posts, Stack Overflow etc. - anything you found useful so the person who picks the task behind you can have some additional context.

4. If you're merging pull request:
	- First make sure Travis is succesful.
	- Once you're satisfied with code style, unit tests and solution in general, merge PR
	- Move the card to **Tested** list.

Miscellaneous:

- Multiple people can work on each card, though in this case it's perhaps better to create additional cards and split behavior between them.
- You can find the URL for cards by clicking on them and then click on "Share and more" link at the bottom of commands on right side.
- Cards can have checklists, feel free to create them if you want to divide it in subtasks (though in this case, it might be better to create additional cards if possible so we can split work amongst multiple developers).


## Xcode project structure

Xcode project contains two targets: `appledoc` and `tests`. The first one is the main target that produces the tool, while later contains all unit tests.

Main project structure follows appledoc tasks as described above. Classes are grouped into components following the tasks. Here's the description of important groups:

- `Common`: Contains common utility files, extensions as well as third party libraries. There should be no file directly in this group, but instead in one of subgroups:
	- `Extensions`: Common extensions to foundation or third party library classes. These are generic extensions, as a good rule of thumb: if extension has no external dependency to other appledoc classes (except the class it extends of course), then it should be added here. There may be extensions that are specific to particular tasks - feel free to create them side by side with classes they extend to keep them together. Whichever way, extensions must always be named `Class+Appledoc.swift` (if there are multiple extensions for the same class, then of course name them differently: `Class+Reading.swift`, `Class+Writing.swift` for example).
	- `Utilities`: Helper files that don't belong to particular group but are used throughout the application. For example: logging etc.
	- `Support`: Support and auto generated files. There should very rarely be need to add anything here, but you may need to update the files (for example bridging header).
	- `Third Party`: This is a parent group for all third party libraries. Each library should be contained inside its own group and folder to make it simpler to remove and update later on.
- `Store`: Contains all in-memory representation classes. These are classes describing everything appledoc parsed.
- `Parser`: Contains all parsing related classes.
- `Processor`: Contains all post-processing classes.
- `Generator`: Contains all HTML, DocSet and other generator classes.
- `Application`: Contains top-level application classes - which launch and bind the rest of the components.

Tests target should follow with similar groups structure as main target.

Miscellaneous notes:

- **Third party libraries:** because appledoc is command line tool, it cannot use frameworks. On the other hand, Swift doesn't support static libraries. Therefore all third party libraries are imported manually. Note that unit tests target is different in that it generates a bundle that supports embedded frameworks.

- **Groups and folders mapping:** The project uses a combination of Xcode groups and folders to keep related classes together. Groups and folders should maintain 1:1 mapping - whenever creating new group, corresponding folder should also be created. There's slight difference between naming both: while groups can and should contain spaces in their names, folders should be stripped of all whitespace. For example: group `Third Party` is linked to folder `ThirdParty`. This 1:1 mapping should only be enforced for first 2 levels, once going deeper, only use groups and keep files in parent folder. The reasoning for this is deeper hierearchies tend to get changed more often than main ones so using folders would unnecessarily complicate work when those changes arise. Group and folder names should be capitalized words.

- **appledoc version and build number:** git is leveraged to automate version and build numbers. Version number is retrieved from latest tag name while build number is total number of commits. There's build script that takes care of it and generates `ApplicationVersion-AutoGenerated!.swift` file during each build. This file is not committed to git, so you'll see it marked red as missing on initial clone. Don't worry, just hit build and it'll be generated for you!


## Unit tests

**All important parts must be covered as much as possible!** This is very important for longevity of the project - failing to add good set of unit tests will result in regressions down the road as more and more developers contribute to the project. How much is "as much as possible"? Ideally 100% coverage. In general don't be afraid to change production code in order to make it more testable, however if tweaks would significantly reduce code readability, or complicate usage, then it's fine to leave parts untested (beware though: often difficulty to test shows design level problems, so be sure to take a step back and think if the approach you chose is the right one - if in doubt, discuss in Slack channel, we're all there to help :)

**Note:** Due to Xcode limitations regarding unit testing command line tool target, all source files added to project target must also be added to unit test target.

That being said, we're using [Quick](https://github.com/Quick/Quick) and [Nimble](https://github.com/Quick/Nimble) for unit testing. Here are some general rules for writing unit tests:

- Each class should be tested with its own test file. If unit tests file starts growing out of control, you can split it into several files. Use extension naming: `ParserSpecs+Basics.swift`, `ParserSpecs+Errors.swift` etc.
- Group related tests under the same `context`.
	- Don't forget contexts can be nested!
	- Top level contexts should be named after the methods they're testing.
	- Typically each "if" would result in its own sub-context. But don't use contexts that only contain single test; group all tests in parent context in this case.
- Each test should ideally only test single behavior. However sometimes this behavior may result in multiple assertions (for example checking if returning array has particular count and each item meets its own expectations).
- Each test should be composed of setup phase, execution phase and verify phase:
	- Setup is where you initialize all objects that will participate in the test
	- Execution is where you exercise the SUT (system under test).
	- Verify is where you verify that results match expectations.
- Avoid use of `setup` and `teardown` (or `beforeEach` in Quick) and instead create all objects in-place. This minimizes state and allows explicit initialization, including all variations needed for that particular test.
	- As a general rule do not be afraid to duplicate setup code; unit tests is the one area where DRY is not so important (in other words: it's more important to have unit tests readable, than to avoid duplication).
	- If initializing objects results in a lot of boilerplate code, consider creating helper methods that will create everything needed, then just setup objects for each test.
	- If the same setup is reused in multiple unit test files, consider creating helper classes that will provide objects. Altenatively use extensions to add test setup methods to production classes.
- Avoid using verification methods; all verification should happen in-place using Nimble matchers. This allows failing test to show directly in Xcode inspector (otherwise you'd need to hunt them down in console because only the "reusable" verification method would be printed as failing one). If you need to verify complex hierarchy of objects in many places, consider [implementing custom matcher](https://github.com/Quick/Nimble#writing-your-own-matchers) instead.
- **Do not test private methods!** While they may seem nice testing targets, implementation may change so a lot of unit tests relying on now no longer existing methods would fail to compile.
	- Instead, unit test public/internal methods only!


## Branches and pull requests

We're using [this git workflow](http://nvie.com/posts/a-successful-git-branching-model/). Main development branch is, well `development` :) It contains the latest codebase. Master branch is only used to push releases, you should never commit or merge to it otherwise. For each task you take, you'll:

1. Create a new branch from development:
	
	```
	git branch <branch-name>
	git checkout <branch_name>
	```

	or shorthand:

	```
	git checkout -b <branch-name>
	```

2. Start work on that branch.

While working:

- Commit often, but try to keep project buildable for each commit.
- Remember you can append new changes on top of existing commit:

	```
	git commit --amend
	```

- And you can force push changes to remote branch afterwards (**but only on your branch!!!***):

	```
	git push --force origin <branch-name>
	```

- Which means you can use this to keep your data backed up remotely and still commit at the end of the day and then continue next day...

- You can also combine commits later on (though it's usually best to do it as you go); interactive rebase is your friend in this case:

	```
	git rebase -i -p HEAD~4
	```

	will do it on last 4 commits. Always use `-p` option because it will preserve branches! Don't rebase past first commit on your branch!

- Try to avoid huge commits; when people will be merging your changes to development (more on this below), it's useful to check them commit by commit so don't try

Then when complete:

1. Perform git rebase on top of development: 
	
	```
	git rebase development
	```

	(if you're working on longer standing task, it's wise to rebase regularly to deal with potentital conflicts while they're still simple).

2. During rebase, you'll need to sort out potential conflicts.
3. Push your branch to github:

	```
	git push -u origin <branch-name>
	```

	-u will setup tracking, so next time you can use:

	```
	git push origin <branch-name>
	```

4. Create pull request at https://github.com/tomaz/appledoc (you should see your branch listed towards the top of the page, just click "Compare and pull request" button).
5. Describe your pull request; be informative so that the one that will merge it knows what's it all about. Include link to issue or Trello card if applicable (for Trello you can find the link by opening the card and clicking on "share and more" link on the bottom of the actions panel on the right).

**IMPORTANT:** When creating pull request, be sure base is set to development! Currently it defaults to master - I'm planning to setup default branch to development once we start work, but may still be set to master for first couple pull requests. Note: it's not the end of the world if you forget this, but you'll need to re-create the pull request, currently github doesn't allow changing base branch after PR is created...

[Here's nice tutorial](https://robots.thoughtbot.com/git-interactive-rebase-squash-amend-rewriting-history) with more detail on above... If intimidated by command line, check [GitUp](http://gitup.co) (free) and [Tower](http://www.git-tower.com) for quality git GUI.


## Logging

appledoc supports 5 levels of logging. From most to least important those are: error, warning, info, verbose, debug. There's corresponding function for each:

- `gerror`: Logs an error. This should be reserved for cases where execution cannot continue in any meaningful manner.
- `gwarning`: Logs a warning. Warnings are potentially serious conditions but ones that still allow execution to continue (probably it leads to an error soon, but not at this point).
- `ginfo`: Main "normal" state logging function. This should be used for all important logs. For example at the beginning of a step. Think of it as the only logs that will show in majority of appledoc runs.
- `gverbose`: Lower priority than info, off by default. This should be used for more details about each step but should still result in readable output.
- `gdebug`: Lowest priority logging statement, off by default. This should only be used for debugging problems so should be restricted for lower level descriptions.

Logging is usually something that's done by feel rather than by following rules. You can go crazy with debug, but must pay attention with the others. It's usually simplest to do a test run with each level and refine as needed...
